; step1_counter.pio
.program step1_counter
.side_set 1 opt                 ; 

.wrap_target
    pull block                      ; Wait for value in TX FIFO, load into OSR
    mov x, osr                      ; Move OSR to X

count:
    irq set 5                       ; Trigger IRQ 5
    jmp pin, end                     ;If pin == 1, go to end; else
    jmp !x end [3] side 1           ; If X == 0, go to end; else , set side pin high (step ON)
    wait 1 irq 4 side 0             ; Wait for IRQ 4 to clear, side pin low (step OFF)
    irq clear 4                     ;
    jmp x-- count                   ; Decrement X, repeat if not zero

end:
    mov isr, x                      ; Move X to ISR
    push noblock                    ; Push ISR to FIFO
    irq 0                           ; Blocking IRQ 0 to signal end of steps
.wrap


; step1_speed.pio
.program step1_speed

; Start: pobierz opóźnienie RAZ i trzymaj w rejestrze X
    pull block                      ; Pobierz liczbę cykli opóźnienia z FIFO
    mov x, osr                      ; Zapisz w rejestrze X (to jest nasza baza czasu)

.wrap_target
    wait 1 irq 5                    ; Czekaj na sygnał od licznika kroków (IRQ 5)
    irq clear 5                     ;
    mov y, x                        ; Przeładuj opóźnienie z X do Y (licznik roboczy)

delay_loop:
    jmp y-- delay_loop              ; Pętla opóźniająca (wykonuje się Y razy)
    irq set 4                       ; Sygnalizuj koniec opóźnienia
.wrap


; step2_counter.pio
.program step2_counter
.side_set 1 opt     ; optional side-set (used to toggle step pin)

.wrap_target
    pull block                      ; Wait for value in TX FIFO, load into OSR
    mov x, osr                      ; Move OSR to X

count:
    irq set 7                       ; Trigger IRQ 7
    jmp pin, end                     ;If pin == 1, go to end; else
    jmp !x end [3] side 1           ; If X == 0, go to end; else, set side pin high (step ON) 
    wait 1 irq 6 side 0               ; Wait for IRQ 6 to clear, side pin low (step OFF)
    irq clear 6                     ;
    jmp x-- count                   ; Decrement X, repeat if not zero

end:
    mov isr, x                      ; Move X to ISR
    push noblock                    ; Push ISR to FIFO
    irq 1                           ; Blocking IRQ 0 to signal end of steps
.wrap


; step2_speed.pio
.program step2_speed

    pull block                      ; 1. Pobierz delay
    mov x, osr                      ; 2. Zapisz w X

.wrap_target
    wait 1 irq 7                    ; 3. Czekaj na IRQ 7
    irq clear 7                     ;
    mov y, x                        ; 4. Przeładuj do Y

delay_loop:
    jmp y-- delay_loop              ; 5. Pętla
    irq set 6                       ; 
.wrap

% c-sdk {
#include "hardware/clocks.h"
#define TARGET_PIO_FREQ 2000000.0f

void step1_counter_program_init(PIO pio, uint sm, uint offset, uint step_pin, uint hold_pin,float freq) {
    pio_sm_config c = step1_counter_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, step_pin);
    sm_config_set_set_pins(&c, step_pin, 1);
    sm_config_set_jmp_pin(&c, hold_pin);

    pio_gpio_init(pio, step_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, step_pin, 1, true);

    float div = clock_get_hz(clk_sys) / (freq);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

void step1_speed_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = step1_speed_program_get_default_config(offset);
    
    float div = (float)clock_get_hz(clk_sys) / TARGET_PIO_FREQ;
    sm_config_set_clkdiv(&c, div); 
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

void step2_counter_program_init(PIO pio, uint sm, uint offset, uint step_pin, uint hold_pin, float freq) {
    pio_sm_config c = step2_counter_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, step_pin);
    sm_config_set_set_pins(&c, step_pin, 1);
    sm_config_set_jmp_pin(&c, hold_pin);

    pio_gpio_init(pio, step_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, step_pin, 1, true);

    float div = clock_get_hz(clk_sys) / (freq);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

void step2_speed_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = step2_speed_program_get_default_config(offset);
    
    float div = (float)clock_get_hz(clk_sys) / TARGET_PIO_FREQ;
    sm_config_set_clkdiv(&c, div); 
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}