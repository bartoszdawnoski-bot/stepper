; step1_counter.pio
.program step1_counter
.side_set 1 opt     ; optional side-set (used to toggle step pin)

.wrap_target
    pull block                      ; Wait for value in TX FIFO, load into OSR
    mov x, osr                      ; Move OSR to X

count:
    irq 5                           ; Trigger IRQ 5
    jmp pin, end                    ; If pin == 1, go to end; else
    jmp !x end [1] side 1           ; If X == 0, go to end; else , set side pin high (step ON)
    irq wait 4 side 0               ; Wait for IRQ 4 to clear, side pin low (step OFF)
    jmp x-- count                   ; Decrement X, repeat if not zero

end:
    mov isr, x                      ; Move X to ISR
    push noblock                    ; Push ISR to FIFO
    irq 0                           ; Blocking IRQ 0 to signal end of steps
.wrap


; step1_speed.pio
.program step1_speed

.wrap_target
    wait 1 irq 5                    ; Wait for IRQ 5 (triggered by step_counter)
    set y, 5                        ; Set Y for delay loop (adjust value as needed)

delay:
    nop [9]                         ; Delay 10 cycles (nop + [9])
    jmp y-- delay                   ; Decrement Y, loop if not zero
    irq clear 4                     ; Clear IRQ 4, allows step_counter to continue
.wrap

; step2_counter.pio
.program step2_counter
.side_set 1 opt     ; optional side-set (used to toggle step pin)

.wrap_target
    pull block                      ; Wait for value in TX FIFO, load into OSR
    mov x, osr                      ; Move OSR to X

count:
    irq 7                           ; Trigger IRQ 7
    jmp pin, end                    ; If pin == 1, go to end; else
    jmp !x end [1] side 1           ; If X == 0, go to end; else, set side pin high (step ON) 
    irq wait 6 side 0               ; Wait for IRQ 6 to clear, side pin low (step OFF)
    jmp x-- count                   ; Decrement X, repeat if not zero

end:
    mov isr, x                      ; Move X to ISR
    push noblock                    ; Push ISR to FIFO
    irq 1                           ; Blocking IRQ 0 to signal end of steps
.wrap


; step2_speed.pio
.program step2_speed

.wrap_target
    wait 1 irq 7                    ; Wait for IRQ 7 (triggered by step_counter)
    set y, 5                        ; Set Y for delay loop (adjust value as needed)

delay:
    nop [9]                         ; Delay 10 cycles (nop + [9])
    jmp y-- delay                   ; Decrement Y, loop if not zero
    irq clear 6                     ; Clear IRQ 6, allows step_counter to continue
.wrap

% c-sdk {
#include "hardware/clocks.h"

void step1_counter_program_init(PIO pio, uint sm, uint offset, uint step_pin, uint hold_pin,float freq) {
    pio_sm_config c = step1_counter_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, step_pin);
    sm_config_set_set_pins(&c, step_pin, 1);
    sm_config_set_jmp_pin(&c, hold_pin);

    pio_gpio_init(pio, step_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, step_pin, 1, true);

    float div = clock_get_hz(clk_sys) / (freq);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

void step1_speed_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = step1_speed_program_get_default_config(offset);

    float div = clock_get_hz(clk_sys) / (freq);
    sm_config_set_clkdiv(&c, div);


    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

void step2_counter_program_init(PIO pio, uint sm, uint offset, uint step_pin, uint hold_pin, float freq) {
    pio_sm_config c = step2_counter_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, step_pin);
    sm_config_set_set_pins(&c, step_pin, 1);
    sm_config_set_jmp_pin(&c, hold_pin);

    pio_gpio_init(pio, step_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, step_pin, 1, true);

    float div = clock_get_hz(clk_sys) / (freq);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

void step2_speed_program_init(PIO pio, uint sm, uint offset, float freq) {
    pio_sm_config c = step2_speed_program_get_default_config(offset);

    float div = clock_get_hz(clk_sys) / (freq);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}